import{_ as a,c as r,j as t,a as i,G as c,a5 as o,B as n,o as l}from"./chunks/framework.ajcgp9jS.js";const y=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"api.md","filePath":"api.md","lastUpdated":null}'),d={name:"api.md"},p={class:"jldocstring custom-block",open:""};function h(f,e,m,u,b,g){const s=n("Badge");return l(),r("div",null,[e[3]||(e[3]=t("ul",null,[t("li",null,[t("a",{href:"#Kerchunk.ReferenceStore"},[t("code",null,"Kerchunk.ReferenceStore")])])],-1)),t("details",p,[t("summary",null,[e[0]||(e[0]=t("a",{id:"Kerchunk.ReferenceStore",href:"#Kerchunk.ReferenceStore"},[t("span",{class:"jlbinding"},"Kerchunk.ReferenceStore")],-1)),e[1]||(e[1]=i()),c(s,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[2]||(e[2]=o('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ReferenceStore</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(filename_or_dict) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Zarr.AbstractStore</span></span></code></pre></div><p>A <code>ReferenceStore</code> is a &quot;fake filesystem&quot; encoded by some key-value store dictionary, either held in memory, or read from a JSON file in the <a href="https://fsspec.github.io/kerchunk/" target="_blank" rel="noreferrer">Kerchunk format</a>.</p><p>Generally, you will only need to construct this if you have an in-memory Dict or other representation, or if you want to explicitly modify the store before constructing a ZGroup, which eagerly loads metadata.</p><p><strong>Extended help</strong></p><p><strong>Implementation</strong></p><p>The reference store has several fields:</p><ul><li><p><code>mapper</code>: The actual key-value store that file information (<code>string of base64 bytes</code>, <code>[single uri]</code>, <code>[uri, byte_offset, byte_length]</code>) is stored in. The type here is parametrized so this may be mutable if in memory, or immutable, e.g a JSON3.Object.</p></li><li><p><code>zmetadata</code>: The toplevel Zarr metadata, sometimes stored separately.</p></li><li><p><code>templates</code>: Key-value store for template expansion, if URLs need to be compressed.</p></li><li><p><code>cache</code>: Key-value store for explicitly downloaded or otherwise modified keys.</p></li></ul><p><a href="https://github.com/JuliaIO/Kerchunk.jl/blob/f1dd5e2aed87e868bb8b4cb7d0b5296cddd38060/src/referencestore.jl#L60-L81" target="_blank" rel="noreferrer">source</a></p>',8))]),e[4]||(e[4]=o('<h2 id="Correction-interface" tabindex="-1">Correction interface <a class="header-anchor" href="#Correction-interface" aria-label="Permalink to &quot;Correction interface {#Correction-interface}&quot;">â€‹</a></h2><p>Kerchunk files often need corrections to the metadata.</p><p>For example, the CF-convention <code>add_offset</code> and <code>scale_factor</code> metadata fields are stored as separate variables in the source data, but should ideally be stored as a single Zarr <code>FixedScaleOffset</code> filter so you can get performance as close to native as possible. Some CF datasets also encode an <code>_Unsigned</code> metadata field, which should simply be used to edit the <code>dtype</code> of the Zarr array.</p><p>Kerchunk also sometimes places the compressor as the last filter, which is technically compliant with Zarr v3 but is not compliant with Zarr v2. This is corrected by moving the compressor to the <code>compressor</code> field of the metadata, but this has to be done before the Zarr is loaded.</p><p>This is the point of the correction interface. As more idiosyncrasies are discovered, they can be added to it.</p><div class="warning custom-block"><p class="custom-block-title">Missing docstring.</p><p>Missing docstring for <code>do_correction!</code>. Check Documenter&#39;s build log for details.</p></div><div class="warning custom-block"><p class="custom-block-title">Missing docstring.</p><p>Missing docstring for <code>add_scale_offset_filter_and_set_mask!</code>. Check Documenter&#39;s build log for details.</p></div><div class="warning custom-block"><p class="custom-block-title">Missing docstring.</p><p>Missing docstring for <code>move_compressor_from_filters!</code>. Check Documenter&#39;s build log for details.</p></div>',8))])}const v=a(d,[["render",h]]);export{y as __pageData,v as default};
